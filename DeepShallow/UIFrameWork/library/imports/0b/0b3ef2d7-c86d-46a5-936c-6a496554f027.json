{
  "__type__": "cc.TextAsset",
  "_name": "atom.d",
  "_objFlags": 0,
  "_native": "",
  "text": "import { IDerivationState_, IObservable, IDerivation, Lambda } from \"../mobx\";\r\nexport declare const $mobx: unique symbol;\r\nexport interface IAtom extends IObservable {\r\n    reportObserved(): any;\r\n    reportChanged(): any;\r\n}\r\nexport declare class Atom implements IAtom {\r\n    name_: string;\r\n    isPendingUnobservation_: boolean;\r\n    isBeingObserved_: boolean;\r\n    observers_: Set<IDerivation>;\r\n    diffValue_: number;\r\n    lastAccessedBy_: number;\r\n    lowestObserverState_: IDerivationState_;\r\n    /**\r\n     * Create a new atom. For debugging purposes it is recommended to give it a name.\r\n     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.\r\n     */\r\n    constructor(name_?: string);\r\n    onBOL: Set<Lambda> | undefined;\r\n    onBUOL: Set<Lambda> | undefined;\r\n    onBO(): void;\r\n    onBUO(): void;\r\n    /**\r\n     * Invoke this method to notify mobx that your atom has been used somehow.\r\n     * Returns true if there is currently a reactive context.\r\n     */\r\n    reportObserved(): boolean;\r\n    /**\r\n     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.\r\n     */\r\n    reportChanged(): void;\r\n    toString(): string;\r\n}\r\nexport declare const isAtom: (x: any) => x is Atom;\r\nexport declare function createAtom(name: string, onBecomeObservedHandler?: () => void, onBecomeUnobservedHandler?: () => void): IAtom;\r\n"
}