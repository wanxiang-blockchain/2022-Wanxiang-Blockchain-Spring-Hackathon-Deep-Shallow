{
  "__type__": "cc.TextAsset",
  "_name": "reaction.d",
  "_objFlags": 0,
  "_native": "",
  "text": "import { IDerivation, IDerivationState_, IObservable, Lambda, TraceMode } from \"../mobx\";\r\n/**\r\n * Reactions are a special kind of derivations. Several things distinguishes them from normal reactive computations\r\n *\r\n * 1) They will always run, whether they are used by other computations or not.\r\n * This means that they are very suitable for triggering side effects like logging, updating the DOM and making network requests.\r\n * 2) They are not observable themselves\r\n * 3) They will always run after any 'normal' derivations\r\n * 4) They are allowed to change the state and thereby triggering themselves again, as long as they make sure the state propagates to a stable state in a reasonable amount of iterations.\r\n *\r\n * The state machine of a Reaction is as follows:\r\n *\r\n * 1) after creating, the reaction should be started by calling `runReaction` or by scheduling it (see also `autorun`)\r\n * 2) the `onInvalidate` handler should somehow result in a call to `this.track(someFunction)`\r\n * 3) all observables accessed in `someFunction` will be observed by this reaction.\r\n * 4) as soon as some of the dependencies has changed the Reaction will be rescheduled for another run (after the current mutation or transaction). `isScheduled` will yield true once a dependency is stale and during this period\r\n * 5) `onInvalidate` will be called, and we are back at step 1.\r\n *\r\n */\r\nexport interface IReactionPublic {\r\n    dispose(): void;\r\n    trace(enterBreakPoint?: boolean): void;\r\n}\r\nexport interface IReactionDisposer {\r\n    (): void;\r\n    $mobx: Reaction;\r\n}\r\nexport declare class Reaction implements IDerivation, IReactionPublic {\r\n    name_: string;\r\n    private onInvalidate_;\r\n    private errorHandler_?;\r\n    requiresObservable_: boolean;\r\n    observing_: IObservable[];\r\n    newObserving_: IObservable[];\r\n    dependenciesState_: IDerivationState_;\r\n    diffValue_: number;\r\n    runId_: number;\r\n    unboundDepsCount_: number;\r\n    isDisposed_: boolean;\r\n    isScheduled_: boolean;\r\n    isTrackPending_: boolean;\r\n    isRunning_: boolean;\r\n    isTracing_: TraceMode;\r\n    constructor(name_: string, onInvalidate_: () => void, errorHandler_?: ((error: any, derivation: IDerivation) => void) | undefined, requiresObservable_?: boolean);\r\n    onBecomeStale_(): void;\r\n    schedule_(): void;\r\n    isScheduled(): boolean;\r\n    /**\r\n     * internal, use schedule() if you intend to kick off a reaction\r\n     */\r\n    runReaction_(): void;\r\n    track(fn: () => void): void;\r\n    reportExceptionInDerivation_(error: any): void;\r\n    dispose(): void;\r\n    getDisposer_(): IReactionDisposer;\r\n    toString(): string;\r\n    trace(enterBreakPoint?: boolean): void;\r\n}\r\nexport declare function onReactionError(handler: (error: any, derivation: IDerivation) => void): Lambda;\r\nexport declare function runReactions(): void;\r\nexport declare const isReaction: (x: any) => x is Reaction;\r\nexport declare function setReactionScheduler(fn: (f: () => void) => void): void;\r\n"
}