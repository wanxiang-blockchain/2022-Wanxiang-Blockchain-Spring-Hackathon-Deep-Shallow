{
  "__type__": "cc.TextAsset",
  "_name": "observablemap.d",
  "_objFlags": 0,
  "_native": "",
  "text": "import { $mobx, IEnhancer, IInterceptable, IInterceptor, IListenable, Lambda, ObservableValue, IAtom } from \"../mobx\";\r\nexport interface IKeyValueMap<V = any> {\r\n    [key: string]: V;\r\n}\r\nexport declare type IMapEntry<K = any, V = any> = [K, V];\r\nexport declare type IMapEntries<K = any, V = any> = IMapEntry<K, V>[];\r\nexport declare type IMapDidChange<K = any, V = any> = {\r\n    observableKind: \"map\";\r\n    debugObjectName: string;\r\n} & ({\r\n    object: ObservableMap<K, V>;\r\n    name: K;\r\n    type: \"update\";\r\n    newValue: V;\r\n    oldValue: V;\r\n} | {\r\n    object: ObservableMap<K, V>;\r\n    name: K;\r\n    type: \"add\";\r\n    newValue: V;\r\n} | {\r\n    object: ObservableMap<K, V>;\r\n    name: K;\r\n    type: \"delete\";\r\n    oldValue: V;\r\n});\r\nexport interface IMapWillChange<K = any, V = any> {\r\n    object: ObservableMap<K, V>;\r\n    type: \"update\" | \"add\" | \"delete\";\r\n    name: K;\r\n    newValue?: V;\r\n}\r\nexport declare const ADD = \"add\";\r\nexport declare const DELETE = \"delete\";\r\nexport declare type IObservableMapInitialValues<K = any, V = any> = IMapEntries<K, V> | IKeyValueMap<V> | Map<K, V>;\r\nexport declare class ObservableMap<K = any, V = any> implements Map<K, V>, IInterceptable<IMapWillChange<K, V>>, IListenable {\r\n    enhancer_: IEnhancer<V>;\r\n    name_: string;\r\n    [$mobx]: {};\r\n    data_: Map<K, ObservableValue<V>>;\r\n    hasMap_: Map<K, ObservableValue<boolean>>;\r\n    keysAtom_: IAtom;\r\n    interceptors_: any;\r\n    changeListeners_: any;\r\n    dehancer: any;\r\n    constructor(initialData?: IObservableMapInitialValues<K, V>, enhancer_?: IEnhancer<V>, name_?: string);\r\n    private has_;\r\n    has(key: K): boolean;\r\n    set(key: K, value: V): this;\r\n    delete(key: K): boolean;\r\n    private updateHasMapEntry_;\r\n    private updateValue_;\r\n    private addValue_;\r\n    get(key: K): V | undefined;\r\n    private dehanceValue_;\r\n    keys(): IterableIterator<K>;\r\n    values(): IterableIterator<V>;\r\n    entries(): IterableIterator<IMapEntry<K, V>>;\r\n    [Symbol.iterator](): IterableIterator<IMapEntry<K, V>>;\r\n    forEach(callback: (value: V, key: K, object: Map<K, V>) => void, thisArg?: any): void;\r\n    /** Merge another object into this object, returns this. */\r\n    merge(other: ObservableMap<K, V> | IKeyValueMap<V> | any): ObservableMap<K, V>;\r\n    clear(): void;\r\n    replace(values: ObservableMap<K, V> | IKeyValueMap<V> | any): ObservableMap<K, V>;\r\n    get size(): number;\r\n    toString(): string;\r\n    toJSON(): [K, V][];\r\n    get [Symbol.toStringTag](): string;\r\n    /**\r\n     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.\r\n     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe\r\n     * for callback details\r\n     */\r\n    observe_(listener: (changes: IMapDidChange<K, V>) => void, fireImmediately?: boolean): Lambda;\r\n    intercept_(handler: IInterceptor<IMapWillChange<K, V>>): Lambda;\r\n}\r\nexport declare var isObservableMap: (thing: any) => thing is ObservableMap<any, any>;\r\n"
}