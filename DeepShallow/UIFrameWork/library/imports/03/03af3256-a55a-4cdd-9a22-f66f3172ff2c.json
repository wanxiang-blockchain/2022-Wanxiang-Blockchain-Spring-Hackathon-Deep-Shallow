{
  "__type__": "cc.TextAsset",
  "_name": "computedvalue.d",
  "_objFlags": 0,
  "_native": "",
  "text": "import { CaughtException, IDerivation, IDerivationState_, IEqualsComparer, IObservable, Lambda, TraceMode } from \"../mobx\";\r\nexport interface IComputedValue<T> {\r\n    get(): T;\r\n    set(value: T): void;\r\n    observe_(listener: (change: IComputedDidChange<T>) => void, fireImmediately?: boolean): Lambda;\r\n}\r\nexport interface IComputedValueOptions<T> {\r\n    get?: () => T;\r\n    set?: (value: T) => void;\r\n    name?: string;\r\n    equals?: IEqualsComparer<T>;\r\n    context?: any;\r\n    requiresReaction?: boolean;\r\n    keepAlive?: boolean;\r\n}\r\nexport declare type IComputedDidChange<T = any> = {\r\n    type: \"update\";\r\n    observableKind: \"computed\";\r\n    object: unknown;\r\n    debugObjectName: string;\r\n    newValue: T;\r\n    oldValue: T | undefined;\r\n};\r\n/**\r\n * A node in the state dependency root that observes other nodes, and can be observed itself.\r\n *\r\n * ComputedValue will remember the result of the computation for the duration of the batch, or\r\n * while being observed.\r\n *\r\n * During this time it will recompute only when one of its direct dependencies changed,\r\n * but only when it is being accessed with `ComputedValue.get()`.\r\n *\r\n * Implementation description:\r\n * 1. First time it's being accessed it will compute and remember result\r\n *    give back remembered result until 2. happens\r\n * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.\r\n * 3. When it's being accessed, recompute if any shallow dependency changed.\r\n *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.\r\n *    go to step 2. either way\r\n *\r\n * If at any point it's outside batch and it isn't observed: reset everything and go to 1.\r\n */\r\nexport declare class ComputedValue<T> implements IObservable, IComputedValue<T>, IDerivation {\r\n    dependenciesState_: IDerivationState_;\r\n    observing_: IObservable[];\r\n    newObserving_: null;\r\n    isBeingObserved_: boolean;\r\n    isPendingUnobservation_: boolean;\r\n    observers_: Set<IDerivation>;\r\n    diffValue_: number;\r\n    runId_: number;\r\n    lastAccessedBy_: number;\r\n    lowestObserverState_: IDerivationState_;\r\n    unboundDepsCount_: number;\r\n    protected value_: T | undefined | CaughtException;\r\n    name_: string;\r\n    triggeredBy_?: string;\r\n    isComputing_: boolean;\r\n    isRunningSetter_: boolean;\r\n    derivation: () => T;\r\n    setter_?: (value: T) => void;\r\n    isTracing_: TraceMode;\r\n    scope_: Object | undefined;\r\n    private equals_;\r\n    private requiresReaction_;\r\n    keepAlive_: boolean;\r\n    /**\r\n     * Create a new computed value based on a function expression.\r\n     *\r\n     * The `name` property is for debug purposes only.\r\n     *\r\n     * The `equals` property specifies the comparer function to use to determine if a newly produced\r\n     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`\r\n     * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.\r\n     * Structural comparison can be convenient if you always produce a new aggregated object and\r\n     * don't want to notify observers if it is structurally the same.\r\n     * This is useful for working with vectors, mouse coordinates etc.\r\n     */\r\n    constructor(options: IComputedValueOptions<T>);\r\n    onBecomeStale_(): void;\r\n    onBOL: Set<Lambda> | undefined;\r\n    onBUOL: Set<Lambda> | undefined;\r\n    onBO(): void;\r\n    onBUO(): void;\r\n    /**\r\n     * Returns the current value of this computed value.\r\n     * Will evaluate its computation first if needed.\r\n     */\r\n    get(): T;\r\n    set(value: T): void;\r\n    trackAndCompute(): boolean;\r\n    computeValue_(track: boolean): T | CaughtException;\r\n    suspend_(): void;\r\n    observe_(listener: (change: IComputedDidChange<T>) => void, fireImmediately?: boolean): Lambda;\r\n    warnAboutUntrackedRead_(): void;\r\n    toString(): string;\r\n    valueOf(): T;\r\n    [Symbol.toPrimitive](): T;\r\n}\r\nexport declare const isComputedValue: (x: any) => x is ComputedValue<unknown>;\r\n"
}