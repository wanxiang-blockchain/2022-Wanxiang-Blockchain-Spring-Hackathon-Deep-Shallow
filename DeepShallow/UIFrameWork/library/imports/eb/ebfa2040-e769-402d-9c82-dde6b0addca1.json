{
  "__type__": "cc.TextAsset",
  "_name": "derivation.d",
  "_objFlags": 0,
  "_native": "",
  "text": "import { IAtom, IDepTreeNode, IObservable } from \"../mobx\";\r\nexport declare enum IDerivationState_ {\r\n    NOT_TRACKING_ = -1,\r\n    UP_TO_DATE_ = 0,\r\n    POSSIBLY_STALE_ = 1,\r\n    STALE_ = 2\r\n}\r\nexport declare enum TraceMode {\r\n    NONE = 0,\r\n    LOG = 1,\r\n    BREAK = 2\r\n}\r\n/**\r\n * A derivation is everything that can be derived from the state (all the atoms) in a pure manner.\r\n * See https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74\r\n */\r\nexport interface IDerivation extends IDepTreeNode {\r\n    observing_: IObservable[];\r\n    newObserving_: null | IObservable[];\r\n    dependenciesState_: IDerivationState_;\r\n    /**\r\n     * Id of the current run of a derivation. Each time the derivation is tracked\r\n     * this number is increased by one. This number is globally unique\r\n     */\r\n    runId_: number;\r\n    /**\r\n     * amount of dependencies used by the derivation in this run, which has not been bound yet.\r\n     */\r\n    unboundDepsCount_: number;\r\n    onBecomeStale_(): void;\r\n    isTracing_: TraceMode;\r\n    /**\r\n     *  warn if the derivation has no dependencies after creation/update\r\n     */\r\n    requiresObservable_?: boolean;\r\n}\r\nexport declare class CaughtException {\r\n    cause: any;\r\n    constructor(cause: any);\r\n}\r\nexport declare function isCaughtException(e: any): e is CaughtException;\r\n/**\r\n * Finds out whether any dependency of the derivation has actually changed.\r\n * If dependenciesState is 1 then it will recalculate dependencies,\r\n * if any dependency changed it will propagate it by changing dependenciesState to 2.\r\n *\r\n * By iterating over the dependencies in the same order that they were reported and\r\n * stopping on the first change, all the recalculations are only called for ComputedValues\r\n * that will be tracked by derivation. That is because we assume that if the first x\r\n * dependencies of the derivation doesn't change then the derivation should run the same way\r\n * up until accessing x-th dependency.\r\n */\r\nexport declare function shouldCompute(derivation: IDerivation): boolean;\r\nexport declare function isComputingDerivation(): boolean;\r\nexport declare function checkIfStateModificationsAreAllowed(atom: IAtom): void;\r\nexport declare function checkIfStateReadsAreAllowed(observable: IObservable): void;\r\n/**\r\n * Executes the provided function `f` and tracks which observables are being accessed.\r\n * The tracking information is stored on the `derivation` object and the derivation is registered\r\n * as observer of any of the accessed observables.\r\n */\r\nexport declare function trackDerivedFunction<T>(derivation: IDerivation, f: () => T, context: any): any;\r\nexport declare function clearObserving(derivation: IDerivation): void;\r\nexport declare function untracked<T>(action: () => T): T;\r\nexport declare function untrackedStart(): IDerivation | null;\r\nexport declare function untrackedEnd(prev: IDerivation | null): void;\r\nexport declare function allowStateReadsStart(allowStateReads: boolean): boolean;\r\nexport declare function allowStateReadsEnd(prev: boolean): void;\r\n/**\r\n * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0\r\n *\r\n */\r\nexport declare function changeDependenciesStateTo0(derivation: IDerivation): void;\r\n"
}