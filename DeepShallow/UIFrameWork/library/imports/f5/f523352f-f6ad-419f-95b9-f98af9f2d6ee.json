{
  "__type__": "cc.TextAsset",
  "_name": "observable.d",
  "_objFlags": 0,
  "_native": "",
  "text": "import { IEnhancer, IEqualsComparer, IObservableArray, IObservableMapInitialValues, IObservableSetInitialValues, IObservableValue, ObservableMap, ObservableSet, Annotation, AnnotationsMap } from \"../mobx\";\r\nexport declare const OBSERVABLE = \"observable\";\r\nexport declare const OBSERVABLE_REF = \"observable.ref\";\r\nexport declare const OBSERVABLE_SHALLOW = \"observable.shallow\";\r\nexport declare const OBSERVABLE_STRUCT = \"observable.struct\";\r\nexport declare type CreateObservableOptions = {\r\n    name?: string;\r\n    equals?: IEqualsComparer<any>;\r\n    deep?: boolean;\r\n    defaultDecorator?: Annotation;\r\n    proxy?: boolean;\r\n    autoBind?: boolean;\r\n};\r\nexport declare const defaultCreateObservableOptions: CreateObservableOptions;\r\nexport declare function asCreateObservableOptions(thing: any): CreateObservableOptions;\r\nexport declare function getEnhancerFromOptions(options: CreateObservableOptions): IEnhancer<any>;\r\nexport declare function getAnnotationFromOptions(options?: CreateObservableOptions): Annotation | undefined;\r\nexport declare function getEnhancerFromAnnotation(annotation?: Annotation): IEnhancer<any>;\r\nexport interface IObservableFactory extends Annotation, PropertyDecorator {\r\n    <T = any>(value: T[], options?: CreateObservableOptions): IObservableArray<T>;\r\n    <T = any>(value: Set<T>, options?: CreateObservableOptions): ObservableSet<T>;\r\n    <K = any, V = any>(value: Map<K, V>, options?: CreateObservableOptions): ObservableMap<K, V>;\r\n    <T extends object>(value: T, decorators?: AnnotationsMap<T, never>, options?: CreateObservableOptions): T;\r\n    box: <T = any>(value?: T, options?: CreateObservableOptions) => IObservableValue<T>;\r\n    array: <T = any>(initialValues?: T[], options?: CreateObservableOptions) => IObservableArray<T>;\r\n    set: <T = any>(initialValues?: IObservableSetInitialValues<T>, options?: CreateObservableOptions) => ObservableSet<T>;\r\n    map: <K = any, V = any>(initialValues?: IObservableMapInitialValues<K, V>, options?: CreateObservableOptions) => ObservableMap<K, V>;\r\n    object: <T = any>(props: T, decorators?: AnnotationsMap<T, never>, options?: CreateObservableOptions) => T;\r\n    /**\r\n     * Decorator that creates an observable that only observes the references, but doesn't try to turn the assigned value into an observable.ts.\r\n     */\r\n    ref: Annotation & PropertyDecorator;\r\n    /**\r\n     * Decorator that creates an observable converts its value (objects, maps or arrays) into a shallow observable structure\r\n     */\r\n    shallow: Annotation & PropertyDecorator;\r\n    deep: Annotation & PropertyDecorator;\r\n    struct: Annotation & PropertyDecorator;\r\n}\r\nexport declare var observable: IObservableFactory;\r\n"
}