{
  "__type__": "cc.TextAsset",
  "_name": "globalstate.d",
  "_objFlags": 0,
  "_native": "",
  "text": "import { IDerivation, IObservable, Reaction } from \"../mobx\";\r\nimport { ComputedValue } from \"./computedvalue\";\r\nexport declare type IUNCHANGED = {};\r\nexport declare class MobXGlobals {\r\n    /**\r\n     * MobXGlobals version.\r\n     * MobX compatiblity with other versions loaded in memory as long as this version matches.\r\n     * It indicates that the global state still stores similar information\r\n     *\r\n     * N.B: this version is unrelated to the package version of MobX, and is only the version of the\r\n     * internal state storage of MobX, and can be the same across many different package versions\r\n     */\r\n    version: number;\r\n    /**\r\n     * globally unique token to signal unchanged\r\n     */\r\n    UNCHANGED: IUNCHANGED;\r\n    /**\r\n     * Currently running derivation\r\n     */\r\n    trackingDerivation: IDerivation | null;\r\n    /**\r\n     * Currently running reaction. This determines if we currently have a reactive context.\r\n     * (Tracking derivation is also set for temporal tracking of computed values inside actions,\r\n     * but trackingReaction can only be set by a form of Reaction)\r\n     */\r\n    trackingContext: Reaction | ComputedValue<any> | null;\r\n    /**\r\n     * Each time a derivation is tracked, it is assigned a unique run-id\r\n     */\r\n    runId: number;\r\n    /**\r\n     * 'guid' for general purpose. Will be persisted amongst resets.\r\n     */\r\n    mobxGuid: number;\r\n    /**\r\n     * Are we in a batch block? (and how many of them)\r\n     */\r\n    inBatch: number;\r\n    /**\r\n     * Observables that don't have observers anymore, and are about to be\r\n     * suspended, unless somebody else accesses it in the same batch\r\n     *\r\n     * @type {IObservable[]}\r\n     */\r\n    pendingUnobservations: IObservable[];\r\n    /**\r\n     * List of scheduled, not yet executed, reactions.\r\n     */\r\n    pendingReactions: Reaction[];\r\n    /**\r\n     * Are we currently processing reactions?\r\n     */\r\n    isRunningReactions: boolean;\r\n    /**\r\n     * Is it allowed to change observables at this point?\r\n     * In general, MobX doesn't allow that when running computations and React.render.\r\n     * To ensure that those functions stay pure.\r\n     */\r\n    allowStateChanges: boolean;\r\n    /**\r\n     * Is it allowed to read observables at this point?\r\n     * Used to hold the state needed for `observableRequiresReaction`\r\n     */\r\n    allowStateReads: boolean;\r\n    /**\r\n     * If strict mode is enabled, state changes are by default not allowed\r\n     */\r\n    enforceActions: boolean | \"always\";\r\n    /**\r\n     * Spy callbacks\r\n     */\r\n    spyListeners: {\r\n        (change: any): void;\r\n    }[];\r\n    /**\r\n     * Globally attached error handlers that react specifically to errors in reactions\r\n     */\r\n    globalReactionErrorHandlers: ((error: any, derivation: IDerivation) => void)[];\r\n    /**\r\n     * Warn if computed values are accessed outside a reactive context\r\n     */\r\n    computedRequiresReaction: boolean;\r\n    /**\r\n     * (Experimental)\r\n     * Warn if you try to create to derivation / reactive context without accessing any observable.\r\n     */\r\n    reactionRequiresObservable: boolean;\r\n    /**\r\n     * (Experimental)\r\n     * Warn if observables are accessed outside a reactive context\r\n     */\r\n    observableRequiresReaction: boolean;\r\n    disableErrorBoundaries: boolean;\r\n    suppressReactionErrors: boolean;\r\n    useProxies: boolean;\r\n    verifyProxies: boolean;\r\n    /**\r\n     * False forces all object's descriptors to\r\n     * writable: true\r\n     * configurable: true\r\n     */\r\n    safeDescriptors: boolean;\r\n}\r\nexport declare let globalState: MobXGlobals;\r\nexport declare function isolateGlobalState(): void;\r\nexport declare function getGlobalState(): any;\r\n/**\r\n * For testing purposes only; this will break the internal state of existing observables,\r\n * but can be used to get back at a stable state after throwing errors\r\n */\r\nexport declare function resetGlobalState(): void;\r\n"
}