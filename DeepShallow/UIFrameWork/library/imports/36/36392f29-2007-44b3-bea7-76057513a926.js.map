{"version":3,"sources":["assets/Script/Common/Utils/Dungeon.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { MathUtils } from \"./MatchUtils\";\n\nexport enum GridType {\n    None,       // 未初始化\n    Floor,      // 地板\n    Wall,       // 墙\n    OpenDoor,       // 门\n    CloseDoor,  //\n}\n\nenum DirType {\n    None,   // 不动\n    Left,\n    Right,\n    Up,\n    Down,\n    All,\n}\n\nconst ALL_DIR_TYPES = [DirType.Left, DirType.Right, DirType.Up, DirType.Down];\n\nexport class Dungeon {\n    numRoomTries = 50;                      // 尝试生成房间的数量\n    extraConnectorChance = 20;              // 房间和走廊连接机会\n    roomExtraSize = 0;\n    windingPercent = 50;\n    width = 51;                             // 地图的宽\n    height = 51;                            // 地图的高\n\n    rooms: cc.Rect[] =[];                   // 房间\n    map: number[] = [];                     // 原点是左下角\n    regions: number[] = [];                      // 区间\n    currentRegion = 0;\n\n    constructor(width: number, height: number) {\n        this.width = width;\n        this.height = height;        \n        for(let i=0; i<width * height; i++) {\n            this.map[i] = GridType.None;\n            this.regions[i] = 0;\n        }\n    }\n\n    public generate() {\n        this.initMap();\n        this.addRooms();\n        this.fillMaze();\n        this.connectRegions();\n        this.removeDeadEnds();\n        return this.map;\n    }\n\n    public initMap() {\n        for(let i=0; i<this.width * this.height; i++) {\n            this.map[i] = GridType.Wall;\n            this.regions[i] = 0;\n        }\n    }\n    public addRooms() {\n        for(let i=0; i<this.numRoomTries; i++) {\n            let size = MathUtils.limitInteger(1, 3+this.roomExtraSize) * 2 + 1;         // 是一个奇数\n            let rectangularity = MathUtils.limitInteger(0, 1+Math.floor(size/2)) * 2;   // 控制矩形宽高比\n            let w = size, h = size;\n            if(0 === MathUtils.limitInteger(0, 1)) w += rectangularity;\n            else h += rectangularity;\n\n            let x = MathUtils.limitInteger(0, Math.floor((this.width-w)/2)) * 2 + 1;\n            let y = MathUtils.limitInteger(0, Math.floor((this.height-h)/2)) * 2 + 1;\n\n            let room = new cc.Rect(x, y, w, h);                                         // 生成一个房间矩形\n            // 检查矩形是否符合规则 -> 即是否有重叠\n            let overlaps = false;\n            for(let r of this.rooms) {\n                if(room.intersects(r)) {\n                    overlaps = true;\n                    break;\n                }\n            }\n            if(overlaps) {      // 有重叠, 放弃该房间\n                continue;\n            }\n            this.currentRegion ++;\n            this._initRoomGrid(room);\n            this.rooms.push(room);\n        }\n    }\n    private _initRoomGrid(room: cc.Rect) {\n        let tmpVec2 = cc.v2(0, 0);\n        for(let i=room.x; i<room.width + room.x; i++) {\n            for(let j=room.y; j<room.height + room.y; j++) {\n                tmpVec2.x = i; tmpVec2.y = j;\n                this.carveGrid(tmpVec2, GridType.Floor);\n            }        \n        }\n        \n    }\n    /** 填充迷宫 */\n    public fillMaze() {\n        for(let y=1; y<this.height; y+=2) {\n            for(let x=1; x<this.width; x+=2) {\n                let grid = cc.v2(x, y);\n                if(this.getGridType(grid) !== GridType.Wall) continue;\n                this._growMaze(grid);\n            }\n        }\n    }\n    \n    private _growMaze(start: cc.Vec2) {\n        let cells: cc.Vec2[] = [];\n        let lastDir = DirType.None;\n        this.currentRegion ++;\n        this.carveGrid(start, GridType.Floor);\n        cells.push(start);\n        while(cells !== null && cells.length !== 0) {\n            let cell = cells[cells.length-1];\n            let unmadeCells: DirType[] = [];\n            for(let dir of ALL_DIR_TYPES) {\n                if(this.canCarve(cell, dir)) unmadeCells.push(dir);\n            }\n            if(unmadeCells.length <= 0) {\n                cells.pop();\n                lastDir = DirType.None;\n                continue;\n            }\n            // 当前grid有可以扩展的方向\n            let dir = DirType.None;             \n            if(unmadeCells.indexOf(lastDir) !== -1 && MathUtils.limitInteger(0, 100) > this.windingPercent) {\n                dir = lastDir;\n            }else {\n                dir = MathUtils.randomArray(unmadeCells);\n            }\n\n            this.carveGrid(cell.add(this.getDirGridOffset(dir)), GridType.Floor);\n            this.carveGrid(cell.add(this.getDirGridOffset(dir).mul(2)), GridType.Floor);\n            cells.push(cell.add(this.getDirGridOffset(dir).mul(2)));\n            lastDir = dir;\n        }\n\n    }\n    public connectRegions() {\n        let connectorRegions: {[key: number]: number[]} = {};\n        let tmpVec2 = cc.v2(0, 0);\n        for(let i=1; i<this.width-1; i++) {\n            for(let j=1; j<this.height-1; j++) {\n                tmpVec2.x = i; tmpVec2.y = j;\n                if(this.getGridType(tmpVec2) !== GridType.Wall) continue;\n\n                let regions: number[] = [];\n                for(let dir of ALL_DIR_TYPES) {\n                    let grid = tmpVec2.add(this.getDirGridOffset(dir));\n                    let region = this.regions[grid.y * this.width + grid.x];\n                    if(region !== 0 && regions.indexOf(region) == -1) regions.push(region);\n                }\n                if(regions.length < 2) continue;\n                connectorRegions[j*this.width + i] = regions;\n            }\n        }\n\n        let connectors: cc.Vec2[] = [];\n        let keys = Object.keys(connectorRegions);\n        for(let key of keys) {\n            connectors.push(this.getGridByIdx(parseInt(key)));\n        }\n\n        let merged: {[key: number]: number} = {};\n        let openRegions: Set<number> = new Set<number>();\n        for(let i=0; i<=this.currentRegion; i++) {\n            merged[i] = i;\n            openRegions.add(i);\n        }\n        let count = 0;\n        while(openRegions.size > 1 && count < 50) {\n            count ++;\n            let connector = MathUtils.randomArray<cc.Vec2>(connectors);\n            this.addJunction(connector);\n\n            let regions = connectorRegions[connector.y * this.width + connector.x].map((v) => merged[v]);\n            \n            let dest = regions[0];\n            regions.shift();\n            let sources = regions;\n            for(let i=0; i<=this.currentRegion; i++) {\n                if(sources.indexOf(merged[i]) !== -1) {\n                    merged[i] = dest;\n                }\n            }\n\n            for(let s of sources) {\n                if(openRegions.has(s)) openRegions.delete(s);\n            }\n            connectors.filter((v) => {return !this.isRemove(merged, connectorRegions, connector, v)});\n        }\n\n    }\n    private addJunction(grid: cc.Vec2) {\n        if(MathUtils.limitInteger(0, 4)) {\n            this.setGridType(grid, MathUtils.limitInteger(0, 3) ? GridType.OpenDoor : GridType.Floor);\n        }else {\n            this.setGridType(grid, GridType.CloseDoor);\n        }\n        \n    }\n    private isRemove(merged: {[key: number]: number}, connectRegions: {[key: number]: number[]}, connector: cc.Vec2, grid: cc.Vec2) {\n        if(connector.sub(grid).len() < 2) return true;\n        let regions = connectRegions[grid.y * this.width + grid.x].map((v) => merged[v]);\n        let set = new Set<number>(regions);\n        if(set.size > 1) return false;\n\n        // if(MathUtils.limitInteger(0, this.extraConnectorChance)) this.addJunction(grid);\n        return true;\n    }\n    public removeDeadEnds() {\n        let done = false;\n        let tmpVec2 = cc.v2(0, 0);\n        let count = 0;\n        while(!done && count < 500) {\n            count ++;\n            done = true;\n            for(let i=1; i<this.width-1; i++) {\n                for(let j=1; j<this.height-1; j++) {\n                    tmpVec2.x = i; tmpVec2.y = j;\n                    if(this.getGridType(tmpVec2) === GridType.Wall) continue;\n                    let exists = 0;\n                    for(let dir of ALL_DIR_TYPES) {\n                        let grid = tmpVec2.add(this.getDirGridOffset(dir));\n                        if(this.map[grid.y * this.width + grid.x] !== GridType.Wall) exists ++;\n                    }                    \n                    if(exists !== 1) continue;\n                    done = false;\n                    this.regions[j * this.height + i] = 0;\n                    this.map[j * this.height + i] = GridType.Wall;\n                }\n            }\n        }\n    }\n    public instanceMap() {\n\n    }\n    \n    public getGridByIdx(idx: number) {\n        let y = Math.floor(idx / this.width);\n        let x = idx - y * this.width;\n        return cc.v2(x, y);\n    }\n\n    /** 雕刻一个格子 */\n    private carveGrid(grid: cc.Vec2, type: GridType) {\n        if(!this.checkGrid(grid)) return ;\n        this.setGridType(grid, type);\n        this.regions[grid.y * this.width + grid.x] = this.currentRegion;\n    }\n    private setGridType(grid: cc.Vec2, type: GridType) {\n        this.map[grid.y * this.width + grid.x] = type;\n    }\n    private checkGrid(grid: cc.Vec2) {\n        if(grid.x <= 0 || grid.x >= this.width-1 || grid.y <= 0 || grid.y >= this.height-1) {\n            console.log(\" set grid type error: \", grid);\n            return false;\n        }\n        return true;\n    }\n    private getGridType(grid: cc.Vec2) {\n        return this.map[grid.y * this.width + grid.x];\n    }\n\n    private canCarve(grid: cc.Vec2, dir: DirType) {\n        let dirGrid = this.getDirGridOffset(dir);\n        let nextGrid = grid.add(dirGrid.mul(3));\n        if(nextGrid.x < 0 || nextGrid.x >= this.width || nextGrid.y < 0 || nextGrid.y >= this.height) {\n            return false;\n        }\n\n        nextGrid = grid.add(dirGrid.mul(2));\n        return this.getGridType(nextGrid) === GridType.Wall;\n    }\n\n    private getDirGridOffset(dir: DirType) {\n        let dirGrid = cc.v2(0, 0);\n        switch(dir) {\n            case DirType.Left:\n                dirGrid.x = -1;\n                break;\n            case DirType.Right:\n                dirGrid.x = 1;\n                break;\n            case DirType.Up:\n                dirGrid.y = 1;\n                break;\n            case DirType.Down:\n                dirGrid.y = -1;\n                break;\n        }\n        return dirGrid;\n    }\n}\n"]}