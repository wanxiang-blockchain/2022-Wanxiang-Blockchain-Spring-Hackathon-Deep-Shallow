{"version":3,"sources":["assets/Script/Common/Light/LightUtils.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { Intersection } from \"./LightStruct\";\n\nexport default class LightUtils {\n\n    /** 获得所有射线与多边形的交点 */\n    public static getIntersections(light: cc.Vec2, polygons: cc.Vec2[][]) {\n        let rayStart = light;\n        let rayEnds = this.getRayEnds(polygons);            // \n        let intersects: Intersection[] = [];\n        for(const rayEnd of rayEnds) {\n            // 这里需要对rayend 进行一次分散, 因为在与多边形交点判断时, 需要判断光线在交点周围的情况\n            \n            let l = this.getNormal(rayEnd.sub(rayStart))\n            for(let i=-1; i<=1; i++) {\n                let tmpRayEnd = rayEnd.add(l.mul(i * 0.001));\n                let intersect = this.getIntersection(polygons, rayStart, tmpRayEnd);\n                if(!intersect) continue;\n                // 计算角度 用来对交点进行排序\n                \n                intersect.angle = Math.atan2(tmpRayEnd.y - rayStart.y, tmpRayEnd.x - rayStart.x);\n                intersects.push(intersect);\n            }\n        }\n        intersects = intersects.sort(function(a,b){\n            return a.angle-b.angle; // 升序\n        });\n\n        return intersects;\n    }\n\n    /** 求垂直向量 */\n    private static getNormal(line: cc.Vec2) {\n        let l = line.normalize();\n        let tmp = l.x; l.x = l.y; l.y = -tmp;\n        return l;\n    }\n\n    /** 获得射线 */\n    private static getRayEnds(polygons: cc.Vec2[][]) {\n        let rayEnds: cc.Vec2[] = [];\n        for(let i=0; i<polygons.length; i++) {\n            let seg = polygons[i];\n            for(let j=0; j<seg.length; j++) {\n                rayEnds.push(seg[j]);\n            }\n        }\n        return rayEnds;\n    }\n\n    /** 获得射线和多边形们最近交点, 有很大的优化空间, 比如建立一个按角度划分的四叉树, 减少遍历次数 */\n    private static getIntersection(polygons: cc.Vec2[][], rayStart: cc.Vec2, rayEnd: cc.Vec2) {\n        let closestIntersect: Intersection = null;  // 交点\n        for(let i=0; i<polygons.length; i++) {\n            let seg = polygons[i];\n            for(let j=0; j<seg.length; j++) {\n                let intersect = this._doGetIntersection(rayStart, rayEnd, seg[j], j === seg.length-1 ? seg[0] : seg[j+1]);\n                if(!intersect) continue;\n                if(!closestIntersect || intersect.len < closestIntersect.len) {\n                    closestIntersect = intersect;\n                }\n            }\n        }\n        return closestIntersect;\n    }\n\n    /** 通过角度剔除交点, 角度是逆时针方向 */\n    public static getIntersectionByAngle(startAngle: number, angleRange: number, light: cc.Vec2, polygons: cc.Vec2[][]) {\n        let endAngle = startAngle + angleRange;\n        startAngle *= 0.017453;\n        endAngle *= 0.017453;\n        // 本质就是以light为原点搭建坐标系\n        let rayEnd1 = cc.v2(Math.cos(startAngle), Math.sin(startAngle)).add(light);\n        let rayEnd2 = cc.v2(Math.cos(endAngle), Math.sin(endAngle)).add(light);\n\n        // 算交点\n        let intersect1 = this.getIntersection(polygons, light, rayEnd1);\n        intersect1.angle = startAngle;\n        let intersect2 = this.getIntersection(polygons, light, rayEnd2);\n        intersect2.angle = endAngle;\n\n        // 获得所有交点\n        let intersects = this.getIntersections(light, polygons);\n        // 剔除角度外的交点, 这里可以优化, 因为intersects是有序的, 可以使用二分法查找\n        // 二分法, 已优化\n        let start = this.binarySearchIntersects(intersects, startAngle, true);\n        let end = this.binarySearchIntersects(intersects, endAngle, false);\n        intersects = intersects.slice(start, end+1);\n\n        intersects.unshift({x:light.x, y: light.y, len: 0}, intersect1)\n        intersects.push(intersect2);\n\n        return intersects;\n    }\n\n\n    private static binarySearchIntersects(arr: Intersection[], angle: number, findFlag = false) {\n        let start = 0, end = arr.length-1;\n        while(end-start > 1){\n            let idx = Math.floor((start + end) / 2);\n            if (angle < arr[idx].angle) {\n                end = idx;\n            } else if (angle > arr[idx].angle) {\n                   start = idx\n            } else {\n                return idx;\n            }\n        }\n        // 没有找到对应的值\n        return findFlag ? end : start;\n    }\n\n    /** 寻找射线和线段的交点 */\n    private static _doGetIntersection(ray1: cc.Vec2, ray2: cc.Vec2, seg1: cc.Vec2, seg2: cc.Vec2) {\n        let r_px = ray1.x;\n        let r_py = ray1.y;\n        let r_dx = ray2.x - ray1.x;\n        let r_dy = ray2.y - ray1.y;\n\n        let s_px = seg1.x;\n        let s_py = seg1.y;\n        let s_dx = seg2.x - seg1.x;\n        let s_dy = seg2.y - seg1.y;\n\n        // 射线长度\n        let r_mag = r_dx * r_dx + r_dy * r_dy;\n        // 线段长度\n        let s_mag = s_dx * s_dx + s_dy * s_dy;\n        // 两向量方向相同, return\n        if(r_dx / r_mag == s_dx / s_mag && r_dy / r_mag == s_dy / s_mag) return null;\n\n        let T2 = (r_dx * (s_py - r_py) + r_dy * (r_px - s_px)) / (s_dx * r_dy - s_dy * r_dx);\n        let T1 = (s_px + s_dx * T2 - r_px) / r_dx;\n\n        // Must be within parametic whatevers for RAY/SEGMENT\n        if(T1 < 0) return null;\n        if(T2 < 0 || T2 > 1) return null;\n    \n        \n        // Return the POINT OF INTERSECTION\n        return {\n            x: r_px + r_dx * T1,\n            y: r_py + r_dy * T1,\n            len: T1\n        };\n    }\n}"]}